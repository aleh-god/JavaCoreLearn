package AnyClassLearn;

public class main {
    public static void main(String[] args) {

        slaveAbstrClass horse;
        horse = new slaveAbstrClass();
        horse.abstrMethod(); // на основе абстрактного метода
        horse.gallop(); // обычный метод

        // Figure figure = new Figure(10, 10); // так нельзя

        Figure figure; // так можно, так как объект мы не создаем, а ссылку или ярлык
        Triangle triangle = new Triangle(10, 8);
        figure = triangle; // Ссылку на объект присваеваем ярлыку мастеркласса
        System.out.println("Площадь равна " + figure.area()); // Используем универсальную команду, для различных методов и их объектов


        // Шаблон Builder вместо конструктора. Вызывается конструктор (или статический метод) со всеми необходимыми параметрами, чтобы получить объект Builder.
        GoodClass goodClass = new GoodClass.Builder(40, 20)
                //  Затем вызываются сеттеры для установки всех необходимых параметров.
                .optFieldOne(2)
                .optFieldTwo(4)
                .optFieldThird(23)
                .optFieldFour(9)
                .build(); // В завершение, вызывается метод build() для генерации объекта, который будет являться неизменным.

        // Исключения
    /*
    try {
    // блок кода, где отслеживаются ошибки
    }
    catch (тип_исключения_1 exceptionObject) {
    // обрабатываем ошибку
    }
    catch (тип_исключения_2 exceptionObject) {
    // обрабатываем ошибку
    }
    finally {
    // код, который нужно выполнить после завершения блока try
    }

    Существует специальный класс для исключений Trowable. В него входят два класса Exception и Error.
    Класс Exception используется для обработки исключений вашей программой. Вы можете наследоваться от него для создания собственных типов исключений.
    Для распространённых ошибок уже существует класс RuntimeException.
    */
        int catNumber;
        int zero;

        try { // мониторим код
            catNumber = 1; // у меня один кот
            zero = 0; // ноль, он и в Африке ноль
            int result = catNumber / zero;
            // Создадим массив из трёх котов
            String[] catNames = {"Васька", "Барсик", "Мурзик"};
            catNames[3] = "Рыжик"; // Ошибка обращения
            System.out.println("Не увидите это сообщение!");
        }
        catch (ArithmeticException e) { // мы уже знали, к какому классу принадлежит получаемая ошибка, поэтому в блоке catch сразу указали конкретный тип
            System.out.println(e + " Нельзя котов делить на ноль!");
        }
        catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("Ошибка: " + e.toString());
        }
        finally { System.out.println("Жизнь продолжается"); }
        // При использовании множественных операторов catch обработчики подклассов исключений должные находиться выше, чем обработчики их суперклассов. Иначе, суперкласс будет перехватывать все исключения, имея большую область перехвата.

        // Собственные исключения и оператор throw
        // Вам нужно создать экземпляр класса Throwable или его наследников. Получить объект класса Throwable можно в операторе catch или стандартным способом через оператор new.
        // throw экземпляр_Throwable

        // Потоки(нити). Класс Thread и интерфейс Runnable

        // Когда запускается любое приложение, то начинает выполняться поток, называемый главным потоком (main). От него порождаются дочерние потоки. Главный поток, как правило, является последним потоком, завершающим выполнение программы.
        /* Класс Thread содержит несколько методов для управления потоками.
        getName() - получить имя потока
        getPriority() - получить приоритет потока
        isAlive() - определить, выполняется ли поток
        join() - ожидать завершение потока
        run() - запуск потока. В нём пишите свой код
        sleep() - приостановить поток на заданное время
        start() - запустить поток
        */

        Thread mainThread = Thread.currentThread(); // Получим информацию о главном потоке
        System.out.println("\nТекущий поток: " + mainThread.getName());

        // Меняем имя и выводим в текстовом поле
        mainThread.setName("CatThread");
        System.out.println("Новое имя потока: " + mainThread); // Вызовем информацию о названии потока без указания метода.
        // В этом случае можно увидеть строчку Thread[main,5,main] - имя потока, его приоритет и имя его группы

        // Создаем свой поток и запускаем через метод start
        // MyThread myThread = new MyThread();
        // После создания нового потока, его нужно запустить с помощью метода start(), который, по сути, выполняет вызов метода run().
        // myThread.start();

        // Как вариант, перенести вызов метода start() в конструктор.
        MyThread myThread = new MyThread();

        // Создание потока с интерфейсом Runnable

    }
}