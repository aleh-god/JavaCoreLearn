package CollectionsAllLearn.MapLearn;
// Интерфейс Map в Java отображает уникальные ключи для значений. Ключ – это объект, который вы используете, чтобы позже получить значение.
//Имея ключ и значение, вы можете поместить значение в объект Map. После помещения значения, вы можете его получить, используя его ключ.

import java.util.*;

public class main {
    public static void main(String[] args) {
        //Map имеет своё реализацию в различных классах, таких как HashMap
        Map m1 = new HashMap();
        m1.put("Маша", "8");
        m1.put("Михаил", "31");
        m1.put("Олег", "12");
        m1.put("Маша", "8"); // Одинаковые элементы добавлять нельзя.
        m1.put("Маша", "100"); // Старый элемент заменяется новым
        m1.put("Денис", "14");

        System.out.println();
        System.out.println("Элементы карты m1: ");
        System.out.println("\t" + m1);
        System.out.println();

        //Возвращает true, если вызываемая карта содержит k как ключ. В противном случае, возвращает false.
        System.out.println("Есть ли в Map.m1 Олег? " + m1.containsKey("Олег"));
        // Возвращает значение, связанное с ключом k.
        System.out.println("Значение, связанное с ключом Олег: " + m1.get("Олег"));
        // Возвращает true, если карта содержит v как значение. В противном случае, возвращает false.
        System.out.println("Обладает Михаил значением 31? " + m1.containsValue("31"));

        Map m2 = new HashMap();
        m2.put("Маша", "8");
        m2.put("Михаил", "31");
        m2.put("Олег", "12");
        m2.put("Денис", "14");

        System.out.println();
        // Возвращает набор, содержащий записи на карте. Набор содержит объекты типа Map.Entry. Этот метод обеспечивает просмотр набора вызывающей карты.
        System.out.println("Метод просмотра набора карты m2: " + m2.entrySet());
        // Возвращает true, если obj является Map и содержит одинаковые записи. В противном случае, возвращает false.
        System.out.println("Сравнение двух Map на одинаковые записи (Очередность элементов тоже решает): " + m1.equals(m2));
        // Возвращает хэш-код для вызываемой карты.
        System.out.println("Хэш-код для m1: " + m1.hashCode());
        System.out.println("Хэш-код для m2: " + m2.hashCode());

        // Вставляет запись в вызываемую карту, перезаписывая любое предыдущее значение, связанное с ключом. Ключ и значения соответствуют k и v.
        // Возвращает ноль, если ключ ещё не существует. В противном случае возвращается предыдущее значение, связанное с ключом.
        System.out.println("Меняем Машу обратно на 100. Старое значение возвращается методом: " + m2.put("Маша", "100"));
        System.out.println("Метод просмотра набора карты m2: " + m2.entrySet());
        System.out.println("Сравнение двух Map на одинаковые записи: " + m1.equals(m2));

        Map m3 = new HashMap();
        // Вставляет все записи из m в эту карту. void putAll(Map m)
        m3.putAll(m2);
        System.out.println("Вставляем все записи в карту m3: " + m3.entrySet());
        // Удаляет запись, чей ключ равен k
        System.out.println("Удаляем запись Михаил: " + m3.remove("Михаил"));
        System.out.println("Новая m3: " + m3.entrySet());
        // Возвращает количество пар ключей/значений в карте.
        System.out.println("Количество объектов в m3: " + m3.size());
        //Возвращает коллекцию значений в карте. Этот метод предоставляет просмотр значений в карте.
        System.out.println("Просмотр значений в карте m3: " + m3.values());
        // Удаляет все пары ключей/значений в вызываемой карте.
        m3.clear();
        // Возвращает true, если вызываемая карта пустая. В противном случае, возвращает false.
        System.out.println("Карта m3 пустая: " + m3.isEmpty());

        System.out.println("\nСоздаём хэш-карту HashMap");
        // Этот конструктор создает стандартный HashMap по умолчанию
        HashMap hm = new HashMap();
        // Этот конструктор инициализирует хэш-карту, используя элементы Map данного объекта m.
        HashMap hm1 = new HashMap(m1);
        System.out.println("\nМетод просмотра набора карты hm1 из m1: " + hm1.entrySet());
        // Этот конструктор инициализирует емкость хэш-карты для заданного целочисленного значения, capacity.
        HashMap hm2 = new HashMap(4);


        //Возвращает коллекцию значений в карте. Этот метод предоставляет просмотр значений в карте.
        System.out.println("Просмотр значений в карте hm1: " + hm1.values());
        // Возвращает количество пар ключей/значений в карте.
        System.out.println("Количество объектов в hm2: " + hm2.size());

        System.out.println("\nПомещаем элементы в hm:");
        // Object put(Object key, Object value) Связывает указанное значение с указанным ключом на этом Map.
        hm.put("Заря", 434.34);
        hm.put("Марк", 123.22);
        hm.put("Айян", 1378.00);
        hm.put("Дэйзи", 99.22);
        hm.put("Михаил", -19.08);

        // Получите итератор в начале коллекции, вызвав метод iterator() коллекции.
        // Возвращает представление (вид) коллекции отображений, содержащихся в этом Map.
        // Из HashMap низведение в Set, так как для HashMap нельзя вызывать итератор.
        Set set = hm.entrySet();
        Iterator i = set.iterator();

        //Настройте цикл, который вызывает hasNext(). Повторяйте цикл, пока hasNext() возвращает true.
        while(i.hasNext()) {
            // Создаем объект интерфейса и передаем ему объект итератора
            //Внутри цикла получите каждый элемент, вызывая next().
            Map.Entry me = (Map.Entry)i.next();
            System.out.print(me.getKey() + ": ");
            System.out.println(me.getValue());
        }
        System.out.println();

        // Вносим 1000 на счёт Зари
        double balance = ((Double)hm.get("Заря")).doubleValue();
        hm.put("Заря", new Double(balance + 1000));
        System.out.println("Новый баланс Зари: " + hm.get("Заря"));

        //TreeMap обеспечивает эффективное средство хранения пар ключ/значение в отсортированном порядке и позволяет быстро извлекать данные.
        //Следует отметить, что, в отличие от хэш-карты, карта деревьев гарантирует, что ее элементы будут отсортированы в порядке возрастания ключа.
        System.out.println("\nСоздаём TreeMap - элементы сортируются при добавлении");

        //Этот конструктор создает пустое дерево, которое будет сортироваться по естественному порядку его ключей.
        TreeMap tm = new TreeMap();
        // Этот конструктор инициализирует древовидную карту с элементами из m, которые будут отсортированы с использованием естественного порядка ключей.
        TreeMap tm1 = new TreeMap(m1);
        //Удаляет все отображения из этой TreeMap.
        tm1.clear();

        // Помещаем элементы в карту - элементы сортируются при добавлении
        tm.put("Заря", new Double(3434.34));
        tm.put("Марк", new Double(123.22));
        tm.put("Айян", new Double(1378.00));
        tm.put("Дэйзи", new Double(99.22));
        tm.put("Михаил", new Double(-19.08));

        // Получаем итератор
        // Получаем вид элементов, так как итератор не может быть создан для TreeMap
        // Set entrySet() Возвращает заданный вид отображений, содержащихся в этом Map.
        Set settm = tm.entrySet();
        Iterator itm = settm.iterator();

        // Отображаем элементы
        while(itm.hasNext()) {
            Map.Entry me = (Map.Entry)itm.next();
            //
            System.out.print(me.getKey() + ": ");
            System.out.println(me.getValue());
        }
        System.out.println();

        // Вносим 1000 на счёт Зари
        double balance2 = ((Double)tm.get("Заря")).doubleValue();
        tm.put("Заря", new Double(balance2 + 1000));
        System.out.println("Новый баланс Зари: " + tm.get("Заря"));

        // Возвращает true, если этот Map содержит отображение для указанного ключа.
        System.out.println("Содержит отображение для Марк в tm: " + tm.containsKey("Марк"));
        //Возвращает true, если этот Map отображает одну или несколько клавиш в указанное значение.
        System.out.println("Есть ли значение -19.08 в tm: " + tm.containsValue(-19.08));
        //Возвращает значение, на которое этот Map отображает указанный ключ.
        System.out.println("Значение tm.Айян равно: " + tm.get("Айян"));
        System.out.println("Возвращает первый (самый низкий) ключ на этом сортированном Map: " + tm.firstKey());
        System.out.println("Возвращает последний (самый высокий) ключ на этом сортированном Map: " + tm.lastKey());

        //Возвращает представление (вид) части этого Map, ключи которой строго меньше, чем toKey.
        System.out.println("Части Map, ключи которой строго меньше, чем Заря: " + tm.headMap("Заря"));



        /* №	Методы и описание

10	Set keySet()
Возвращает Set вид ключей, содержащихся в этом Map.
12	Object put(Object key, Object value)
Связывает указанное значение с указанным ключом на этом Map.
13	void putAll(Map map)
Копирует все отображения с указанного Map на этот Map.
14	Object remove(Object key)
Удаляет отображение этого ключа из этого TreeMap, если оно присутствует.
15	int size()
Возвращает количество отображений ключ-значение на этом Map.
16	SortedMap subMap(Object fromKey, Object toKey)
Возвращает представление (вид) части этого Map, ключи которого варьируется от fromKey, включительно, до toKey, исключительно.
17	SortedMap tailMap(Object fromKey)
Возвращает представление (вид) части этого Map, ключи которого больше или равны fromKey.
18	Collection values()
Возвращает представление (вид) коллекции значений, содержащихся на этом Map.
         */
    }
}