package StringRegexLearn;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

//Регулярные выражения представляют мощный инструмент для обработки строк.
// Регулярные выражения позволяют задать шаблон, которому должна соответствовать строка или подстрока.
public class Main {
    public static void main(String[] agrs) {
        //Split - разделение
        String text = "FIFA       will, never. regret it!";
        String[] words = text.split("\\s*(\\s|,|!|\\.)\\s*");
        for(String word : words) {
            System.out.println(word);
        }
/*
Подвыражние "\\s" по сути представляет пробел.
Звездочка указывает, что символ может присутствовать от 0 до бесконечного количества раз.
То есть добавляем звездочку и мы получаем неопределенное количество идущих подряд пробелов - "\\s*"
(то есть неважно, сколько пробелов между словами). Причем пробелы может вообще не быть.

В скобках указывает группа выражений, которая может идти после неопределенного количества пробелов.
Группа позволяет нам определить набо значений через вертикальную черту, и подстрока должна соответствовать одному из этих значений.
То есть в группе "\\s|,|!|\\." подстрока может соответствовать пробелу, запятой, восклицательному знаку или
 точке. Причем поскольку точка представляет специальную последовательность, то, чтобы указать,
 что мы имеем в виду имеено знак точки, а не специальную последовательность, перед точкой ставим слеши.
 */
        //matches - совпадения. принимает регулярное выражение и возвращает true, если строка соответствует этому выражению. Иначе возвращает false.
        String input = "+12343454556";
        boolean result = input.matches("(\\+*)\\d{11}");
        if(result){
            System.out.println("It is a phone number");
        }
        else{
            System.out.println("It is not a phone number!");
        }
/*
В данном случае в регулярном выражение сначала определяется группа "(\\+*)".
То есть вначале может идти знак плюса, но также он может отсутствовать.
Далее смотрим, соответствуют ли последующие 11 символов цифрам.
Выражение "\\d" представляет цифровой символ, а число в фигурных скобках - {11} - сколько раз
данный тип символов должен повторяться. То есть мы ищем строку, где вначале может идти знак плюс
(или он может отсутствовать), а потом идет 11 цифровых символов.
 */


        System.out.println("Класс Pattern и Matcher");
    //Само регулярное выражение представляет шаблон для поиска совпадений в строке.
        input = "Hello";
        //Данный метод возвращает true, если последовательность символов input полностью соответствует шаблону строки pattern
        boolean found = Pattern.matches("Hello", input);
        if(found)
            System.out.println("Найдено");
        else
            System.out.println("Не найдено");

    //вначале надо создать объект Pattern с помощью статического метода compile(),
    //который позволяет установить шаблон:
    input = "Hello world and hell.";
    Pattern pattern = Pattern.compile("Hello");
    //Затем у объекта Matcher вызывается метод matches() для поиска соответствий шаблону в тексте
    Matcher matcher = pattern.matcher(input);
    //boolean matches(): возвращает true, если вся строка совпадает с шаблоном
    boolean found2 = matcher.matches();
        if(found2)
            System.out.println("Найдено");
        else
                System.out.println("Не найдено");

        input = "Hello Java! Hello JavaScript! JavaSE 8.";
        // Слово "Java" в начале говорит о том, что все совпадения в строке должны начинаться на Java.
        // Выражение (\\w*) означает, что после "Java" в совпадении может находиться любое количество алфавитно-цифровых символов.
        // Выражение \w означает алфавитно-цифровой символ, а звездочка после выражения указывает на неопределенное их количество - их может быть один, два, три или вообще не быть.
        // И чтобы java не рассматривала \w как эскейп-последовательность, как \n, то выражение экранируется еще одним слешем.
        pattern = Pattern.compile("Java(\\w*)");
        matcher = pattern.matcher(input);
        //boolean find(): возвращает true, если в строке есть подстрока, которая совпадает с шаблоном, и переходит к этой подстроке
        while(matcher.find())
            //String group(): возвращает подстроку, которая совпала с шаблоном в результате вызова метода find. Если совпадение отсутствует, то метод генерирует исключение IllegalStateException.
            System.out.println(matcher.group());

        //String replaceAll(String str): заменяет все найденные совпадения подстрокой str и возвращает измененную строку с учетом замен
        String newStr = matcher.replaceAll("HTML");
        System.out.println(newStr); // Hello HTML! Hello HTML! HTML 8.

        //С помощью метода String[] split(CharSequence input) класса Pattern можно разделить строку на массив подстрок по определенному разделителю.
        input = "Hello Java! Hello JavaScript! JavaSE 8.";
        pattern = Pattern.compile("[ ,.!?]");
        String[] words2 = pattern.split(input);
        for(String word:words2)
            System.out.println(word);

        // Для более точной и изощренной разбивки нам следует применять элементы регулярных выражений.
        input = "Hello Java! Hello JavaScript! JavaSE 8.";
        pattern = Pattern.compile("\\\\s*(\\\\s|,|!|\\\\.)\\\\s*");
        String[] words3 = pattern.split(input);
        for(String word:words3)
            System.out.println(word);
    }
}